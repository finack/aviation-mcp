/* tslint:disable */
/* eslint-disable */
/**
 * AviationWeather.gov API
 * New data API of AviationWeather.gov. This supercedes the ADDS Data Server and AviationWeather Web Services.
 *
 * The version of the OpenAPI document: 3.12
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';

export interface DataserverAirepRequest {
    startTime?: string;
    endTime?: string;
    hoursBeforeNow?: number;
    format?: DataserverAirepFormatEnum;
    boundingBox?: string;
    radialDistance?: string;
}

export interface DataserverGairmetRequest {
    startTime?: string;
    endTime?: string;
    hoursBeforeNow?: number;
    format?: DataserverGairmetFormatEnum;
    boundingBox?: string;
}

export interface DataserverMetarsRequest {
    stationString?: string;
    startTime?: string;
    endTime?: string;
    hoursBeforeNow?: number;
    format?: DataserverMetarsFormatEnum;
    mostRecent?: boolean;
    mostRecentForEachStation?: DataserverMetarsMostRecentForEachStationEnum;
    boundingBox?: string;
}

export interface DataserverSigmetRequest {
    startTime?: string;
    endTime?: string;
    hoursBeforeNow?: number;
    format?: DataserverSigmetFormatEnum;
    boundingBox?: string;
}

export interface DataserverTafsRequest {
    stationString?: string;
    startTime?: string;
    endTime?: string;
    hoursBeforeNow?: number;
    format?: DataserverTafsFormatEnum;
    mostRecent?: boolean;
    mostRecentForEachStation?: DataserverTafsMostRecentForEachStationEnum;
    boundingBox?: string;
}

/**
 * DataserverApi - interface
 * 
 * @export
 * @interface DataserverApiInterface
 */
export interface DataserverApiInterface {
    /**
     * Return aircraft data
     * @summary Dataserver for AIREPs and PIREPs
     * @param {string} [startTime] Start time  * &#x60;yyyymmdd_hhmm&#x60;  * &#x60;yyyy-mm-ddThh:mm:ssZ&#x60; 
     * @param {string} [endTime] End time  * &#x60;yyyymmdd_hhmm&#x60;  * &#x60;yyyy-mm-ddThh:mm:ssZ&#x60; 
     * @param {number} [hoursBeforeNow] Number of hours before now to search
     * @param {'xml' | 'csv'} [format] Output format
     * @param {string} [boundingBox] Geographic bounding box (lat0, lon0, lat1, lon1)
     * @param {string} [radialDistance] Circular bounds defined by latitude, longitude and radial distance in statute miles\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataserverApiInterface
     */
    dataserverAirepRaw(requestParameters: DataserverAirepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Return aircraft data
     * Dataserver for AIREPs and PIREPs
     */
    dataserverAirep(requestParameters: DataserverAirepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Return G-AIRMETs
     * @summary Dataserver for G-AIRMETs
     * @param {string} [startTime] Start time  * &#x60;yyyymmdd_hhmm&#x60;  * &#x60;yyyy-mm-ddThh:mm:ssZ&#x60; 
     * @param {string} [endTime] End time  * &#x60;yyyymmdd_hhmm&#x60;  * &#x60;yyyy-mm-ddThh:mm:ssZ&#x60; 
     * @param {number} [hoursBeforeNow] Number of hours before now to search
     * @param {'xml' | 'csv'} [format] Output format
     * @param {string} [boundingBox] Geographic bounding box (lat0, lon0, lat1, lon1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataserverApiInterface
     */
    dataserverGairmetRaw(requestParameters: DataserverGairmetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Return G-AIRMETs
     * Dataserver for G-AIRMETs
     */
    dataserverGairmet(requestParameters: DataserverGairmetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * METAR reports
     * @summary Dataserver for METARs
     * @param {string} [stationString] Station ID(s) Note: must specify stationString or bounding box (minLat, ...)
     * @param {string} [startTime] Start time  * &#x60;yyyymmdd_hhmm&#x60;  * &#x60;yyyy-mm-ddThh:mm:ssZ&#x60; 
     * @param {string} [endTime] End time  * &#x60;yyyymmdd_hhmm&#x60;  * &#x60;yyyy-mm-ddThh:mm:ssZ&#x60; 
     * @param {number} [hoursBeforeNow] Number of hours before now to search
     * @param {'xml' | 'csv'} [format] Output format
     * @param {boolean} [mostRecent] Single most recent METAR
     * @param {'constraint' | 'postfilter'} [mostRecentForEachStation] Most recent METAR per station
     * @param {string} [boundingBox] Geographic bounding box (lat0, lon0, lat1, lon1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataserverApiInterface
     */
    dataserverMetarsRaw(requestParameters: DataserverMetarsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * METAR reports
     * Dataserver for METARs
     */
    dataserverMetars(requestParameters: DataserverMetarsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Return SIGMETs
     * @summary Dataserver for SIGMETs
     * @param {string} [startTime] Start time  * &#x60;yyyymmdd_hhmm&#x60;  * &#x60;yyyy-mm-ddThh:mm:ssZ&#x60; 
     * @param {string} [endTime] End time  * &#x60;yyyymmdd_hhmm&#x60;  * &#x60;yyyy-mm-ddThh:mm:ssZ&#x60; 
     * @param {number} [hoursBeforeNow] Number of hours before now to search
     * @param {'xml' | 'csv'} [format] Output format
     * @param {string} [boundingBox] Geographic bounding box (lat0, lon0, lat1, lon1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataserverApiInterface
     */
    dataserverSigmetRaw(requestParameters: DataserverSigmetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Return SIGMETs
     * Dataserver for SIGMETs
     */
    dataserverSigmet(requestParameters: DataserverSigmetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Return TAF data
     * @summary Dataserver for TAFs
     * @param {string} [stationString] Station ID(s) Note: must specify stationString or bounding box (minLat, ...)
     * @param {string} [startTime] Start time  * &#x60;yyyymmdd_hhmm&#x60;  * &#x60;yyyy-mm-ddThh:mm:ssZ&#x60; 
     * @param {string} [endTime] End time  * &#x60;yyyymmdd_hhmm&#x60;  * &#x60;yyyy-mm-ddThh:mm:ssZ&#x60; 
     * @param {number} [hoursBeforeNow] Number of hours before now to search
     * @param {'xml' | 'csv'} [format] Output format
     * @param {boolean} [mostRecent] Single most recent TAF
     * @param {'constraint' | 'postfilter'} [mostRecentForEachStation] Most recent TAF per station
     * @param {string} [boundingBox] Geographic bounding box (lat0, lon0, lat1, lon1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataserverApiInterface
     */
    dataserverTafsRaw(requestParameters: DataserverTafsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Return TAF data
     * Dataserver for TAFs
     */
    dataserverTafs(requestParameters: DataserverTafsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

}

/**
 * 
 */
export class DataserverApi extends runtime.BaseAPI implements DataserverApiInterface {

    /**
     * Return aircraft data
     * Dataserver for AIREPs and PIREPs
     */
    async dataserverAirepRaw(requestParameters: DataserverAirepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['startTime'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['endTime'] = requestParameters['endTime'];
        }

        if (requestParameters['hoursBeforeNow'] != null) {
            queryParameters['hoursBeforeNow'] = requestParameters['hoursBeforeNow'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['boundingBox'] != null) {
            queryParameters['boundingBox'] = requestParameters['boundingBox'];
        }

        if (requestParameters['radialDistance'] != null) {
            queryParameters['radialDistance'] = requestParameters['radialDistance'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/data/dataserver?requestType=retrieve&dataSource=aircraftreports`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Return aircraft data
     * Dataserver for AIREPs and PIREPs
     */
    async dataserverAirep(requestParameters: DataserverAirepRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.dataserverAirepRaw(requestParameters, initOverrides);
    }

    /**
     * Return G-AIRMETs
     * Dataserver for G-AIRMETs
     */
    async dataserverGairmetRaw(requestParameters: DataserverGairmetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['startTime'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['endTime'] = requestParameters['endTime'];
        }

        if (requestParameters['hoursBeforeNow'] != null) {
            queryParameters['hoursBeforeNow'] = requestParameters['hoursBeforeNow'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['boundingBox'] != null) {
            queryParameters['boundingBox'] = requestParameters['boundingBox'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/data/dataserver?requestType=retrieve&dataSource=gairmets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Return G-AIRMETs
     * Dataserver for G-AIRMETs
     */
    async dataserverGairmet(requestParameters: DataserverGairmetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.dataserverGairmetRaw(requestParameters, initOverrides);
    }

    /**
     * METAR reports
     * Dataserver for METARs
     */
    async dataserverMetarsRaw(requestParameters: DataserverMetarsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['stationString'] != null) {
            queryParameters['stationString'] = requestParameters['stationString'];
        }

        if (requestParameters['startTime'] != null) {
            queryParameters['startTime'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['endTime'] = requestParameters['endTime'];
        }

        if (requestParameters['hoursBeforeNow'] != null) {
            queryParameters['hoursBeforeNow'] = requestParameters['hoursBeforeNow'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['mostRecent'] != null) {
            queryParameters['mostRecent'] = requestParameters['mostRecent'];
        }

        if (requestParameters['mostRecentForEachStation'] != null) {
            queryParameters['mostRecentForEachStation'] = requestParameters['mostRecentForEachStation'];
        }

        if (requestParameters['boundingBox'] != null) {
            queryParameters['boundingBox'] = requestParameters['boundingBox'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/data/dataserver?requestType=retrieve&dataSource=metars`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * METAR reports
     * Dataserver for METARs
     */
    async dataserverMetars(requestParameters: DataserverMetarsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.dataserverMetarsRaw(requestParameters, initOverrides);
    }

    /**
     * Return SIGMETs
     * Dataserver for SIGMETs
     */
    async dataserverSigmetRaw(requestParameters: DataserverSigmetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['startTime'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['endTime'] = requestParameters['endTime'];
        }

        if (requestParameters['hoursBeforeNow'] != null) {
            queryParameters['hoursBeforeNow'] = requestParameters['hoursBeforeNow'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['boundingBox'] != null) {
            queryParameters['boundingBox'] = requestParameters['boundingBox'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/data/dataserver?requestType=retrieve&dataSource=airsigmets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Return SIGMETs
     * Dataserver for SIGMETs
     */
    async dataserverSigmet(requestParameters: DataserverSigmetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.dataserverSigmetRaw(requestParameters, initOverrides);
    }

    /**
     * Return TAF data
     * Dataserver for TAFs
     */
    async dataserverTafsRaw(requestParameters: DataserverTafsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['stationString'] != null) {
            queryParameters['stationString'] = requestParameters['stationString'];
        }

        if (requestParameters['startTime'] != null) {
            queryParameters['startTime'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['endTime'] = requestParameters['endTime'];
        }

        if (requestParameters['hoursBeforeNow'] != null) {
            queryParameters['hoursBeforeNow'] = requestParameters['hoursBeforeNow'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['mostRecent'] != null) {
            queryParameters['mostRecent'] = requestParameters['mostRecent'];
        }

        if (requestParameters['mostRecentForEachStation'] != null) {
            queryParameters['mostRecentForEachStation'] = requestParameters['mostRecentForEachStation'];
        }

        if (requestParameters['boundingBox'] != null) {
            queryParameters['boundingBox'] = requestParameters['boundingBox'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/data/dataserver?requestType=retrieve&dataSource=tafs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Return TAF data
     * Dataserver for TAFs
     */
    async dataserverTafs(requestParameters: DataserverTafsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.dataserverTafsRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const DataserverAirepFormatEnum = {
    Xml: 'xml',
    Csv: 'csv'
} as const;
export type DataserverAirepFormatEnum = typeof DataserverAirepFormatEnum[keyof typeof DataserverAirepFormatEnum];
/**
 * @export
 */
export const DataserverGairmetFormatEnum = {
    Xml: 'xml',
    Csv: 'csv'
} as const;
export type DataserverGairmetFormatEnum = typeof DataserverGairmetFormatEnum[keyof typeof DataserverGairmetFormatEnum];
/**
 * @export
 */
export const DataserverMetarsFormatEnum = {
    Xml: 'xml',
    Csv: 'csv'
} as const;
export type DataserverMetarsFormatEnum = typeof DataserverMetarsFormatEnum[keyof typeof DataserverMetarsFormatEnum];
/**
 * @export
 */
export const DataserverMetarsMostRecentForEachStationEnum = {
    Constraint: 'constraint',
    Postfilter: 'postfilter'
} as const;
export type DataserverMetarsMostRecentForEachStationEnum = typeof DataserverMetarsMostRecentForEachStationEnum[keyof typeof DataserverMetarsMostRecentForEachStationEnum];
/**
 * @export
 */
export const DataserverSigmetFormatEnum = {
    Xml: 'xml',
    Csv: 'csv'
} as const;
export type DataserverSigmetFormatEnum = typeof DataserverSigmetFormatEnum[keyof typeof DataserverSigmetFormatEnum];
/**
 * @export
 */
export const DataserverTafsFormatEnum = {
    Xml: 'xml',
    Csv: 'csv'
} as const;
export type DataserverTafsFormatEnum = typeof DataserverTafsFormatEnum[keyof typeof DataserverTafsFormatEnum];
/**
 * @export
 */
export const DataserverTafsMostRecentForEachStationEnum = {
    Constraint: 'constraint',
    Postfilter: 'postfilter'
} as const;
export type DataserverTafsMostRecentForEachStationEnum = typeof DataserverTafsMostRecentForEachStationEnum[keyof typeof DataserverTafsMostRecentForEachStationEnum];
